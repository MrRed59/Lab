#pragma once
#include <iostream>
#include <vector>

using namespace std;

template <class T>														//описание шаблонного класса Элемент бинарного дерева
class Tree
{
	T data;																//объявляется переменная Значение элемента
	Tree* left;															//объявляется указатель Элемент слева
	Tree* right;														//объявляется указатель Элемент справа
	Tree* parent;														//объявляется указатель Элемент предок

public:

	Tree(T);															//объявляется Конструктор с параметрами
	~Tree();															//объявляется Деструктор

	void insertLeft(T);													//объявляется метод Вставить элемент слева
	void insertRight(T);												//объявляется метод Вставить элемент справа
	static void preOrder(Tree<T>*);										//объявляется метод Вывести значения элементов (сверху вниз)
	static void inOrder(Tree<T>*);										//объявляется метод Вывести значения элементов (слева направо)
	static void postOrder(Tree<T>*);									//объявляется метод Вывести значения элементов (cниз вверх)
	void printTree(int);												//объявляется метод Вывести значения элементов (горизонтально)
	void levelscan();													//объявляется метод Вывести значения элементов (вертикально)
	void printVTree(int);												//объявляется метод Вывести значения элементов (вертикально)
	static Tree<T>* balancedTree(int n);								//объявляется метод Создать идеально сбалансированное дерево
	Tree<T>* ejectLeft();												//объявляется метод Извлечь поддерево слева
	Tree<T>* ejectRight();												//объявляется метод Извлечь поддерево справа
	void deleteLeft();													//объявляется метод Удалить поддерево слева
	void deleteRight();													//объявляется метод Удалить поддерево справа
	Tree<T>* copyTree();												//объявляется метод Копировать дерево
	void findElement_insertLeft(Tree<T>*, T, T);						//объявляется метод Найти элемент и вставить слева
	void findElement_insertRight(Tree<T>*, T, T);						//объявляется метод Найти элемент и добавить справа
	int getAmountOfNodes();												//объявляется метод Найти количество элементов
	int getHeight();													//объявляется метод Найти высоту дерева

	Tree<T>* getLeft()													//реализация метода Получить значение элемента слева
	{
		return left;													//возвращается значение элемента слева
	}

	Tree<T>* getRight()													//реализация метода Получить значение элемента справа
	{
		return right;													//возвращается значение элемента справа
	}

	Tree<T>* getParent()												//реализация метода Получить значение элемента предка
	{
		return parent;													//возвращается значение элемента предка
	}

	T getData()															//реализация метода Получить значение элемента
	{
		if (this != NULL)												//проверяется существование элемента
		{
			return data;												//возвращается значение элемента
		}
		else
		{
			return NULL;												//возвращается значение "данные отсутствуют"
		}
	}

	void setData(T dt)													//реализация метода Изменить значение элемента
	{
		data = dt;														//задаётся значение элемента
	}

	void addLeftTree(Tree<T>* tree)										//реализация метода Добавить элемент слева
	{
		left = tree;													//задаётся значение элемента слева
	}

	void addRightTree(Tree<T>* tree)									//реализация метода Добавить элемент справа
	{
		right = tree;													//задаётся значение элемента справа
	}
};

template <class T>														//реализация Конструктора с параметрами
Tree<T>::Tree(T dt)									
{
	data = dt;															//задаётся значение элемента
	left = NULL;														//задаётся значение элемента слева
	right = NULL;														//задаётся значение элемента справа
	parent = NULL;														//задаётся значение элемента предка
}

template <class T>														//реализация Деструктора
Tree<T>::~Tree()
{
	delete this->left;													//удаляется элемент слева
	delete this->right;													//удаляется элемент справа
}

template <class T>														//реализация метода Вставить элемент слева
void Tree<T>::insertLeft(T dt)
{
	Tree<T>* temp = new Tree(dt);										//создаётся новый элемент

	if (this->left != NULL)												//проверяется существование элемента слева
	{
		this->left->parent = temp;										//задаётся элементу слева значение элемента предока
	}
	
	temp->left = this->left;											//задаётся новому элементу значение элемента слева
	this->left = temp;													//задаётся текущему элементу значение элемента слева
	temp->parent = this;												//задаётся новому элементу значение элемента предка
}

template <class T>														//реализация метода Вставить элемент справа
void Tree<T>::insertRight(T dt)
{
	Tree<T>* temp = new Tree(dt);										//создаётся новый элемент

	if (this->right != NULL)											//проверяется существование элемента справа
	{
		this->right->parent = temp;										//задаётся элементу справа значение элемента предока
	}

	temp->right = this->right;											//задаётся новому элементу значение элемента слева
	this->right = temp;													//задаётся текущему элементу значение элемента слева
	temp->parent = this;												//задаётся новому элементу значение элемента предка
}

template <class T>														//реализация метода Вывести значения элементов (сверху вниз)
void Tree<T>::preOrder(Tree<T>* temp)
{
	if (temp != NULL)													//проверяется существование элемента
	{
		cout << temp->getData() << "   ";								//выводится значение элемента
		preOrder(temp->left);											//переход к элементу слева
		preOrder(temp->right);											//переход к элементу справа
	}
}

template <class T>														//реализация метода Вывести значения элементов (слева направо)
void Tree<T>::inOrder(Tree<T>* temp)
{
	if (temp != NULL)													//проверяется существование элемента
	{
		inOrder(temp->left);											//переход к элементу слева
		cout << temp->getData() << "   ";								//выводится значение элемента
		inOrder(temp->right);											//переход к элементу справа
	}
}

template <class T>														//реализация метода Вывести значения элементов (cниз вверх)
void Tree<T>::postOrder(Tree<T>* temp)
{
	if (temp != NULL)													//проверяется существование элемента
	{	
		postOrder(temp->left);											//переход к элементу слева
		postOrder(temp->right);											//переход к элементу справа
		cout << temp->getData() << "   ";								//выводится значение элемента
	}
}

template <class T>														//реализация метода Вывести значения элементов (горизонтально)
void Tree<T>::printTree(int level)
{
	if (this != NULL)													//проверяется существование элемента
	{
		this->right->printTree(level + 1);								//переход к элементу справа

		for (int i = 1; i < level; i++)									//выводятся пробелы
		{
			cout << "  ";
		}

		cout << this->getData() << endl;								//выводится значение элемента
		this->left->printTree(level + 1);								//переход к элементу слева
	}
}

template <class T>														//реализация метода Вывести значения элементов (вертикально)
void Tree<T>::levelscan()
{
	vector<Tree<T>*> arr;												//создаётся контейнер элементов
	Tree<T>* temp = this;												//создаётся элемент равный текущему

	arr.push_back(temp);												//добавляется в контейнер текущий элемент

	for (int i = 0; i < this->getAmountOfNodes(); i++)					//перечисляются элементы дерева
	{
		if (arr.at(i)->left != NULL)									//проверяется существование элемента слева
		{
			arr.push_back(arr.at(i)->left);								//добавляется в контейнер элемент слева от текущего
		}

		if (arr.at(i)->right != NULL)									//проверяется существование элемента справа
		{
			arr.push_back(arr.at(i)->right);							//добавляется в контейнер элемент справа от текущего
		}
	}

	for (int i = 0; i < arr.size(); i++)								//перечисляются элементы контейнера
	{
		cout << arr.at(i)->getData() << "  ";							//выводится значение текущего элемента
	}

	cout << endl;
}

template <class T>														//реализация метода Создать идеально сбалансированное дерево
Tree<T>* Tree<T>::balancedTree(int n)
{
	T dt;																//объявляется переменная Значение элемента

	if (n <= 0)															//проверяется значение Размер дерева
	{
		return NULL;													//возвращается значение "данные отсутствуют"
	}
	else
	{
		cout << "Введите значение Элемента:  ";
		cin >> dt;														//вводится значение Значение элемента

		Tree<T>* temp = new Tree<T>(dt);								//создаётся новый элемент
		temp->addLeftTree(balancedTree(n / 2));							//добавляется элемент слева
		temp->addRightTree(balancedTree(n - n / 2 - 1));				//добавляется элемент справа

		return temp;													//возвращается значение элемента
	}
}

template <class T>														//реализация метода Извлечь поддерево слева
Tree<T>* Tree<T>::ejectLeft()
{
	if (this->left != NULL)												//проверяется существование элемента слева
	{
		Tree<T>* temp = this->left;										//создаётся новый элемент равный элементу слева
		this->left = NULL;												//задаётся текущему элементу значение элемента слева
		return temp;													//возвращается новый элемент
	}
	else
	{
		return NULL;													//возвращается значение "данные отсутствуют"
	}
}

template <class T>														//реализация метода Извлечь поддерево справа
Tree<T>* Tree<T>::ejectRight()
{
	if (this->right != NULL)											//проверяется существование элемента справа
	{
		Tree<T>* temp = this->right;									//создаётся новый элемент равный элементу справа
		this->right = NULL;												//задаётся текущему элементу значение элемента слева
		return temp;													//возвращается новый элемент
	}
	else
	{
		return NULL;													//возвращается значение "данные отсутствуют"
	}
}

template <class T>														//реализация метода Удалить поддерево слева
void Tree<T>::deleteLeft()
{
	Tree<T>* temp = this->ejectLeft();									//создаётся новый элемент равный элементу полученному методом Извлечь поддерево слева
	delete temp;														//удаляется новый элемент
}

template <class T>														//реализация метода Удалить поддерево справа
void Tree<T>::deleteRight()
{
	Tree<T>* temp = this->ejectRight();									//создаётся новый элемент равный элементу полученному методом Извлечь поддерево справа
	delete temp;														//удаляется новый элемент
}

template <class T>														//реализация метода Копировать дерево
Tree<T>* Tree<T>::copyTree()
{
	Tree<T>* tree = new Tree<T>(this->data);							//создаётся новый элемент равный текущему элементу

	if (this->parent != NULL)											//проверяется существование элемента предка
	{
		tree->parent = this->parent;									//задаётся новому элементу значение элемента предка
	}

	if (this->left != NULL)												//проверяется существование элемента слева
	{
		tree->left = this->left->copyTree();							//задаётся новому элементу значение элемента слева
	}

	if (this->right != NULL)											//проверяется существование элемента справа
	{
		tree->right = this->right->copyTree();							//задаётся новому элементу значение элемента справа
	}

	return tree;														//возвращается новый элемент
}

template <class T>														//реализация метода Найти элемент и вставить слева
void Tree<T>::findElement_insertLeft(Tree<T>* temp, T dt1, T dt2)
{
	if (temp != NULL)													//проверяется существование элемента
	{
		findElement_insertLeft(temp->getLeft(), dt1, dt2);				//переход к левому элементу

		if (dt1 == temp->getData())										//проверяется значение элемента
		{
			temp->insertLeft(dt2);										//вставляется новый элемент слева
		}

		findElement_insertLeft(temp->getRight(), dt1, dt2);				//переход к элементу справа
	}
}

template <class T>														//реализация метода Найти элемент и вставить справа
void Tree<T>::findElement_insertRight(Tree<T>* temp, T dt1, T dt2)
{
	if (temp != NULL)													//проверяется существование элемента
	{
		findElement_insertRight(temp->getLeft(), dt1, dt2);				//переход к левому элементу

		if (dt1 == temp->getData())										//проверяется значение элемента
		{
			temp->insertRight(dt2);										//вставляется новый элемент справа
		}

		findElement_insertRight(temp->getRight(), dt1, dt2);			//переход к элементу справа
	}
}

template <class T>														//реализация метода Найти количество элементов
int Tree<T>::getAmountOfNodes()
{
	int left = 0;														//задаётся значение количества элементов слева
	int right = 0;														//задаётся значение количества элементов справа
	
	if (this == NULL)													//проверяется существование первого элемента
	{
		return 0;														//возвращается количество элементов
	}

	if ((this->left == NULL) && (this->right == NULL))					//проверяется существование элементов слева и справа
	{
		return 1;														//возвращается количество элементов
	}

	if (this->left != NULL)												//проверяется существование элемента слева
	{
		left = this->left->getAmountOfNodes();							//переход к элементу слева
	}

	if (this->right != NULL)											//проверяется существование элемента справа
	{
		right = this->right->getAmountOfNodes();						//переход к элементу справа
	}

	return (left + right + 1);											//возвращается количество элементов дерева
}

template <class T>														//реализация метода Найти высоту дерева
int Tree<T>::getHeight()
{
	int left = 0;														//задаётся значение Количество уровней слева
	int right= 0;														//задаётся значение Количество уровней справа
	int hadd = 0;

	if (this == NULL)													//проверяется существование первого элемента
	{
		return 0;
	}

	if (this->left != NULL)												//проверяется существование элемента слева
	{
		left = this->left->getHeight();									//переход к элементу слева
	}

	if (this->right != NULL)											//проверяется существование элемента справа
	{
		right = this->right->getHeight();								//переход к элементу справа
	}

	if (left >= right)													//проверяется где больше уровней слева или справа
	{
		return (left + 1);												//возвращается количество уровней
	}
	else
	{
		return (right + 1);												//возвращается количество уровней
	}
}